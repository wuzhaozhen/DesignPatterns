# 结构型模式
## 代理模式（Proxy Pattern）
### 1. 概述
>   代理模式是常用的结构型设计模式之一，当无法直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，所访问的真实对象与代理对象需要实现相同的接口。根据代理模式的使用目的不同，代理模式又可以分为多种类型，例如保护代理、远程代理、虚拟代理、缓冲代理等，它们应用于不同的场合，满足用户的不同需求。

### 2. 定义
> 给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。

### 3. 主要角色
1. Subject（抽象主题角色）：它声明了真实主题和代理主题的共同接口，这样一来在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程。
2. Proxy（代理主题角色）：它包含了对真实主题的引用，从而可以在任何时候操作真实主题对象；在代理主题角色中提供一个与真实主题角色相同的接口，以便在任何时候都可以替代真实主题；代理主题角色还可以控制对真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。通常，在代理主题角色中，客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作，而不仅仅是单纯调用真实主题对象中的操作。
3. RealSubject（真实主题角色）：它定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作。

### 4. 备注

#### 静态代理
1. 继承方式：不推荐
2. 聚合方式：推荐

#### 动态代理

##### JDK动态代理
1. 创建一个实现接口InvocationHandler的类，它必须实现invoke的方法。
2. 创建被代理的类及接口。
3. 调用Proxy的静态方法，创建一个代理类：Proxy.newProxyInstance(ClassLoader loader,new Class[] interfaces,InvocationHandler h);
4. 通过代理调用方法。

> 注： 只能代理实现了接口的类;没有实现接口的类不能实现JDK的动态代理。

##### CGLIB动态代理
> 注：针对类来实现代理的；对指定目标类产生一个子类，通过方法拦截技术拦截多有父类方法的调用。

